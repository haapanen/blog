[{"content":"The problem I recently wanted to test Azure Workbook as a tool for monitoring dashboards. One challenge that I ran into is Workbook uses Azure permissions to grant access to both the Workbook itself and any logs / metrics it\u0026rsquo;s trying to show. It wasn\u0026rsquo;t exactly obvious what built-in Azure roles are needed to provide access to a Workbook that uses Application Insights metrics/logs stored in Log Analytics Workspace.\nSolution Azure Workbook Grant Workbook Reader (b279062a-9be3-42a0-92ae-8b3cf002ec4d) scoped to the Workbook to the user / group. This grants view access to the workbook.\nApplication Insights Grant Monitoring Reader (43d0d8ad-25c7-4714-9337-8ba259a9fe05) scoped to the Application Insights to the user / group. This grants reader access to Application Insights.\nLog Analytics Workspace This depends on how Log Analytics is used. Log Analytics supports both access to all logs within the workspace or access to logs scoped to the resource user has read access to.\nIf you wish to grant access to all logs within the workspace, grant Log Analytics Data Reader (3b03c2da-16b3-4a49-8834-0f8130efdd3b). This grants access to query \u0026amp; search all logs within the workspace.\nIf you wish to grant access to logs from resources user has access to, you don\u0026rsquo;t need to grant anything at the log analytics workspace level. To grant access to specific resource\u0026rsquo;s logs, grant Monitoring Reader (43d0d8ad-25c7-4714-9337-8ba259a9fe05) access to the resource and ensure the log analytics workspace access control mode is set to Use resource or workspace permissions.\n","permalink":"https://jussihaapanen.com/posts/minimal-permissions-for-azure-workbook/","summary":"\u003ch2 id=\"the-problem\"\u003eThe problem\u003c/h2\u003e\n\u003cp\u003eI recently wanted to test Azure Workbook as a tool for monitoring dashboards. One challenge that I ran into is Workbook uses Azure permissions to grant access to both the Workbook itself and any logs / metrics it\u0026rsquo;s trying to show. It wasn\u0026rsquo;t exactly obvious what built-in Azure roles are needed to provide access to a Workbook that uses Application Insights metrics/logs stored in Log Analytics Workspace.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003ch3 id=\"azure-workbook\"\u003eAzure Workbook\u003c/h3\u003e\n\u003cp\u003eGrant \u003ccode\u003eWorkbook Reader\u003c/code\u003e (\u003ccode\u003eb279062a-9be3-42a0-92ae-8b3cf002ec4d\u003c/code\u003e) scoped to the Workbook to the user / group. This grants view access to the workbook.\u003c/p\u003e","title":"Minimal permissions for Azure Workbook, Log Analytics Workspace \u0026 Application Insights"},{"content":"Introduction You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It\u0026rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in Creating an application with plugin support.\nIt\u0026rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I\u0026rsquo;d prefer to be initialized and injected by the .NET Core DI.\nExample case Imagine we\u0026rsquo;re developing a software where we receive messages from an external system and would like to deliver those to various other systems. We could implement the event handler as an Azure Function Appyo and add various integrations to other systems.\nOverview of the imaginary system\nIn the example code I\u0026rsquo;ve implemented the event handler as a .NET Core background service. The full example code is available at GitHub\nWe\u0026rsquo;ll use the .NET Core documentation plugin application example as the starting point for the system. In the example the project structure is following:\nAppWithPlugin PluginBase HelloPlugin In our case we\u0026rsquo;ll be implementing something similar with slightly different names:\nAppWithPlugin --\u0026gt; NetCorePluginDI PluginBase --\u0026gt; NetCorePluginDI.PluginBase HelloPlugin --\u0026gt; NetCorePluginDI.Integrations.* Most of the code will stay the same.\nAs the plugins will be integrations, I\u0026rsquo;ve named the IPlugin interface from the original example to IIntegration. The rest of the interface stays mostly the same:\n1 2 3 4 5 6 public interface IIntegration { string Name { get; } string Description { get; } Task ExecuteAsync(string message, CancellationToken cancellationToken); } This interface will be implemented by all of the plugins (Blob storage, HTTP and DB plugin). Below is a simplified version of the blob storage plugin.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class BlobStorageArchiveIntegration : IIntegration { private readonly ILogger\u0026lt;BlobStorageArchiveIntegration\u0026gt; _logger; public BlobStorageArchiveIntegration(ILogger\u0026lt;BlobStorageArchiveIntegration\u0026gt; logger) { _logger = logger; } public string Name { get; } = \u0026#34;Blob Storage Archive\u0026#34;; public string Description { get; } = \u0026#34;An integration to archive messages to Blob Storage\u0026#34;; public Task ExecuteAsync(string message, CancellationToken cancellationToken) { // Let\u0026#39;s pretend we\u0026#39;re archiving to Blob Storage _logger.LogInformation($\u0026#34;Archiving message [{message}] to Blob Storage\u0026#34;); return Task.CompletedTask; } } It will receive a message and \u0026ldquo;store\u0026rdquo; it to the blob storage (for demonstration purposes we\u0026rsquo;ll just log the message).\nThe problem The above example with the original plugin example will work but there\u0026rsquo;s one major issue: All of the plugins need some sort of configuration. Blob storage and DB integrations need a connection string, HTTP integration needs an URL to send the message to.\nWe could approach this by initializing the settings in the plugin by reading the settings from a file, injecting and using the IConfiguration interface or through some other method. However it would require us to define the settings initialization logic for each integration separately.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class BlobStorageArchiveIntegration : IIntegration { private readonly ILogger\u0026lt;BlobStorageArchiveIntegration\u0026gt; _logger; public BlobStorageArchiveIntegration(ILogger\u0026lt;BlobStorageArchiveIntegration\u0026gt; logger) { _logger = logger; } public string Name { get; } = \u0026#34;Blob Storage Archive\u0026#34;; public string Description { get; } = \u0026#34;An integration to archive messages to Blob Storage\u0026#34;; public Task InitializeAsync() { // Read settings from somewhere and store them locally // ... } public Task ExecuteAsync(string message, CancellationToken cancellationToken) { // Let\u0026#39;s pretend we\u0026#39;re archiving to Blob Storage _logger.LogInformation($\u0026#34;Archiving message [{message}] to Blob Storage\u0026#34;); return Task.CompletedTask; } } I\u0026rsquo;d prefer not having to specify initialization logic on each integration. Additionally this is pretty much a solved problem by the .NET Core DI, we could just use it instead.\nThe solution Let\u0026rsquo;s define a class that we\u0026rsquo;ll inject to the integration.\n1 2 3 4 public class HttpIntegrationSettings { public string Url { get; set; } } Let\u0026rsquo;s use the settings in the integration.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HttpIntegration : IIntegration { private readonly ILogger\u0026lt;HttpIntegration\u0026gt; _logger; private readonly HttpIntegrationSettings _settings; public HttpIntegration(ILogger\u0026lt;HttpIntegration\u0026gt; logger, HttpIntegrationSettings settings) { _logger = logger; _settings = settings; } public string Name { get; } = \u0026#34;HTTP\u0026#34;; public string Description { get; } = \u0026#34;An integration to send messages to a REST endpoint\u0026#34;; public Task ExecuteAsync(string message, CancellationToken cancellationToken) { // Let\u0026#39;s pretend we\u0026#39;re sending messages to another service _logger.LogInformation($\u0026#34;Sending message [{message}] to [{_settings.Url}]\u0026#34;); return Task.CompletedTask; } } Now the question is, how will we inform the DI framework about the HttpIntegrationSettings class and that it should load the settings from the IConfiguration providers?\nWe can achieve that by changing the module loading code. Let\u0026rsquo;s start by defining an interface that all injected settings classes will be implementing.\n1 2 3 public interface ISettings { } Let\u0026rsquo;s just define an empty interface. It\u0026rsquo;s just to declare the type is injectable as an interface. We could also use a naming convention such as if type name ends in Settings, we\u0026rsquo;ll inject it as settings. I prefer to be explicit.\nOnce we\u0026rsquo;ve added the ISetting interface and implemented it in HttpIntegrationSettings, we can implement the additional plugin code to instantiate and inject settings instances to the service provider.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 private static void RegisterIntegrationsFromAssembly(IServiceCollection services, IConfiguration configuration, Assembly assembly) { foreach (var type in assembly.GetTypes()) { // Register all classes that implement the IIntegration interface if (typeof(IIntegration).IsAssignableFrom(type)) { // Add as a singleton as the Worker is a singleton and we\u0026#39;ll only have one // instance. If this would be a Controller or something else with clearly defined // scope that is not the lifetime of the application, use AddScoped. services.AddSingleton(typeof(IIntegration), type); } // Register all classes that implement the ISettings interface if (typeof(ISettings).IsAssignableFrom(type)) { var settings = Activator.CreateInstance(type); // appsettings.json or some other configuration provider should contain // a key with the same name as the type // e.g. \u0026#34;HttpIntegrationSettings\u0026#34;: { ... } if (!configuration.GetSection(type.Name).Exists()) { // If it does not contain the key, throw an error throw new ArgumentException($\u0026#34;Configuration does not contain key [{type.Name}]\u0026#34;); } configuration.Bind(type.Name, settings); // Settings can be singleton as we\u0026#39;ll only ever read it services.AddSingleton(type, settings); } } } We\u0026rsquo;ll register the integration as previously. For all interfaces implementing the ISettings interface we\u0026rsquo;ll create the instance for the type. Then we\u0026rsquo;ll ensure that the type name exists as a key in the settings (e.g. appsettings.json, environment variables or in another configuration provider). If the key exists, let\u0026rsquo;s bind the object to the instance and register the settings to the service provider.\nThis way we\u0026rsquo;ll able utilize the existing infrastructure to load settings for the plugins.\nLet\u0026rsquo;s run the application:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Loading integrations from: \\Path\\To\\NetCorePluginDI\\NetCorePluginDI.Integrations.BlobStorageArchive\\bin\\Debug\\netstandard2.0\\NetCorePluginDI.Integrations.BlobStorageArchive.dll Loading integrations from: \\Path\\TNetCorePluginDI\\NetCorePluginDI.Integrations.Http\\bin\\Debug\\netstandard2.0\\NetCorePluginDI.Integrations.Http.dll info: NetCorePluginDI.Integrations.BlobStorageArchive.BlobStorageArchiveIntegration[0] Archiving message [Worker running at: 6.7.2020 21.51.14 +03:00] to Blob Storage info: NetCorePluginDI.Integrations.Http.HttpIntegration[0] Sending message [Worker running at: 6.7.2020 21.51.14 +03:00] to [https://localhost:3000/api/message] info: Microsoft.Hosting.Lifetime[0] Application started. Press Ctrl+C to shut down. info: Microsoft.Hosting.Lifetime[0] Hosting environment: Development info: Microsoft.Hosting.Lifetime[0] Content root path: \\Path\\To\\\\NetCorePluginDI\\NetCorePluginDI info: NetCorePluginDI.Integrations.BlobStorageArchive.BlobStorageArchiveIntegration[0] Archiving message [Worker running at: 6.7.2020 21.51.15 +03:00] to Blob Storage info: NetCorePluginDI.Integrations.Http.HttpIntegration[0] Sending message [Worker running at: 6.7.2020 21.51.15 +03:00] to [https://localhost:3000/api/message] As you can see, we\u0026rsquo;ll load integrations from two DLLs, the Blob Storage and HTTP integration DLLs. The system receives a message every second and sends it to the integrations. In the log output you can see HttpIntegration logging the endpoint url that was defined in the project appsettings.json (https://localhost:3000/api/message).\nThis can be extended even further. If we have a type we\u0026rsquo;d like to inject to the plugin we can implement another interface. Let\u0026rsquo;s call it IInjectedDependency. It\u0026rsquo;s an empty interface. All types that implement this interface will be registered to the service provider.\n1 2 3 4 5 6 7 8 9 10 11 public interface IInjectedDependency { } public class Service : IInjectedDependency { public void DoWork() { // ... } } We could then register all the types implementing IInjectedDependency in the RegisterIntegrationsFromAssembly method.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 if (typeof(IInjectedDependency).IsAssignableFrom(type)) { // Get all of the interfaces the type implements except // the IInjectedDependency var implementedInterfaces = type.GetInterfaces().Where(i =\u0026gt; i != typeof(IInjectedDependency)).ToList(); // Register as implemented interfaces if (implementedInterfaces.Any()) { foreach (var interfaceType in implementedInterfaces) { // Injected dependency lifetime must be considered // Transient is used as an example but correct lifetime // must be specified based on the use case services.AddTransient(interfaceType, type); } } else { // No implemented interface, register as self services.AddTransient(type); } } Additionally we\u0026rsquo;ll check if the type implements any interfaces. If it does, we\u0026rsquo;ll register the type as implemented interfaces. If not, we\u0026rsquo;ll register to type as self.\nThis way we can fully utilize the .NET Core DI framework within the plugins.\n","permalink":"https://jussihaapanen.com/posts/dotnet-core-plugin-dependency-injection/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eYou might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It\u0026rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in \u003ca href=\"https://docs.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support\"\u003eCreating an application with plugin support\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIt\u0026rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I\u0026rsquo;d prefer to be initialized and injected by the .NET Core DI.\u003c/p\u003e","title":".NET Core plugin dependency injection"},{"content":"Earlier today I had a need for a PlantUML API that could generate PlantUML diagrams without having to install the necessary dependencies on my PC. To achieve this I decided to write a small API using ASP.NET Core.\nI was thinking of just calling the PlantUML binary with the input data from a HTTP POST body. There could be some security implications but I was the only user of the system so it didn\u0026rsquo;t really matter. I was thinking piping the input data should be a very simple thing to do. It sure was in the end but there were a few things that I forgot about when dealing with streams.\nI implemented an API for it and started writing code to do the piping.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var process = new Process { StartInfo = new ProcessStartInfo { FileName = _appSettings.JavaExecutablePath, Arguments = $\u0026#34;-jar {_appSettings.PlantUMLPath} -pipe\u0026#34; RedirectStandardInput = true, RedirectStandardOutput = true, } }; process.Start(); await userInputtedPlantUMLStream.CopyToAsync(process.StandardInput.BaseStream); var outputStream = new MemoryStream(); await process.StandardOutput.BaseStream.CopyToAsync(outputStream); process.WaitForExit(); outputStream.Seek(0, SeekOrigin.Begin); return outputStream; I thought this should do the trick. I started the API and did a request but the application would just hang. After quick debugging I noticed the application was hanging at:\n1 await process.StandardOutput.BaseStream.CopyToAsync(outputStream); Took me a while to figure out what was going on. I was trying to look at examples of reading standard output stream in .NET Core documentation and Stack Overflow. I looked at the examples and it seemed all them did the same things as I did. Turns out I missed one key thing. None of the examples were piping in the data\u0026hellip; There was one crucial thing I forgot to do: I should close the standard input once I\u0026rsquo;m done piping the data in. The fix was really simple after all\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var process = new Process { StartInfo = new ProcessStartInfo { FileName = _appSettings.JavaExecutablePath, Arguments = $\u0026#34;-jar {_appSettings.PlantUMLPath} -pipe\u0026#34; RedirectStandardInput = true, RedirectStandardOutput = true, } }; process.Start(); await userInputtedPlantUMLStream.CopyToAsync(process.StandardInput.BaseStream); // One should not forget to close the stdin.. :) process.StandardInput.Close(); var outputStream = new MemoryStream(); await process.StandardOutput.BaseStream.CopyToAsync(outputStream); process.WaitForExit(); outputStream.Seek(0, SeekOrigin.Begin); return outputStream; One missing line can make a huge difference.\n","permalink":"https://jussihaapanen.com/posts/piping-data-in-dotnet-core/","summary":"\u003cp\u003eEarlier today I had a need for a \u003ca href=\"http://plantuml.com/\"\u003ePlantUML\u003c/a\u003e API that could generate PlantUML\ndiagrams without having to install the necessary dependencies on my PC. To achieve this I decided\nto write a small API using ASP.NET Core.\u003c/p\u003e\n\u003cp\u003eI was thinking of just calling the PlantUML binary with the input data from a HTTP POST body. There\ncould be some security implications but I was the only user of the system so it didn\u0026rsquo;t really matter.\nI was thinking piping the input data should be a very simple thing to do. It sure was in the end but\nthere were a few things that I forgot about when dealing with streams.\u003c/p\u003e","title":"Piping data to an application in .NET Core"},{"content":"I had to recently figure out a way to query database objects based on user input without knowing beforehand which classes user wants to query. Basically user would input a type and the system would find it’s child types from a database table. The children would then be fetched based on a set of rules (we do not want all items on the table, just the ones linked to the parent).\nThere was a “no raw SQL” limitation on the project and I had the data model mapped as NHibernate classes so my initial idea was to use reflection to match the inputted class name with the actual NHibernate class (e.g. user input of MyClass would be mapped to Foo.Bar.MyClass) and then use NHibernate session to simply query for the objects. This would also let me easily verify that the database actually contains the specific model as I could just find the mapping class for the object type based on the NHibernate mapping class convention (e.g. MyClassMap, YourClassMap). If there was no map, there was no table on the database meaning the user input was invalid.\nIt was a fairly simple process to do the initial input to object type mapping and simply querying the objects. I was quickly able to fetch a list of objects in the database based on just the type. Basically NHibernate let’s you query objects by type name string and specifying the return type as an “object”.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // NHibernate entities are stored in a single assembly // Get all classes from the assembly that MyClass is in var entities = Assembly.GetAssembly(typeof(MyClass)) .GetTypes() .Where(x =\u0026gt; x.IsClass) .ToList(); // Input from user var objectTypeName = \u0026#34;MyClass\u0026#34;; // See if the type actually exists var objectType = entities .SingleOrDefault(x =\u0026gt; x.FullName.Split(\u0026#39;.\u0026#39;).Last() == objectTypeName); // Check if object type was actually found if (objectType == null) { // Input isn\u0026#39;t valid throw ... } // We need to fetch as \u0026#34;object\u0026#34; as we do not know the type // compile time. // We\u0026#39;ll pass the object type name as a parameter to tell NHibernate // what the type actually is. // NHibernate session should be opened before var objects = session.Query\u0026lt;object\u0026gt;(objectType.FullName); I could then use reflection to access properties of the actual type:\n1 2 3 4 5 6 7 // An object taken from the result set from a session.Query call var someObject = objects.FirstOrDefault(); // Read the value of someObject.SomeProperty var value = objectType .GetProperty(\u0026#34;SomeProperty\u0026#34;) .GetValue(someObject, null); Console.WriteLine(value); While it was simple to query all objects in the database the next issue was a bit more puzzling for me. Previously I’ve used Fluent NHibernate to do the queries with LINQ but I couldn’t do that anymore in the same exact way as I didn’t know which fields I would have to use for filtering. The fields weren’t same for each class either. I couldn’t use reflection for the filtering as that’d mean I’d have to read all objects from a single table into memory and do the filtering there.\nAfter some searching I figured out C# expression trees are probably the feature I’m looking for. LINQ queries are based on them after all. I was quickly able to find some examples about how other’s have used them to implement dynamic queries. I wanted to include objects where SomeProperty contained the text I was looking for. I ended up with code like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var item = Expression.Parameter(typeof(object), \u0026#34;item\u0026#34;); // Where(item =\u0026gt; item.SomeProperty) var property = Expression.Property(item, \u0026#34;SomeProperty\u0026#34;); // Where(item =\u0026gt; item.SomeProperty.Contains) var containsMethod = typeof(string) .GetMethod(\u0026#34;Contains\u0026#34;, new[]{typeof(string)); // What we\u0026#39;re searching for (e.g. SomeProperty.Contains(\u0026#34;foo\u0026#34;)) var searchExpression = Expression.Constant(\u0026#34;foo\u0026#34;, typeof(string)); // Call the \u0026#34;Contains\u0026#34; method for the \u0026#34;SomeProperty\u0026#34; with // searchExpression as the constant to compare with var methodExpression = Expression .Call(property, containsMethod, searchExpression); // Create a lambda to use inside the where call var lambda = Expression.Lambda\u0026lt;Func\u0026lt;object, bool\u0026gt;\u0026gt;(methodExpression, item); // Do the query with the expression var objects = session .Query\u0026lt;object\u0026gt;(objectType.FullName).Where(lambda); I ran into a problem with this. “object” doesn’t have a property of “SomeProperty”. I tried to switch the type in the Expression.Parameter call to typeof(objectType) but then the lambda would fail as the types didn’t match. I couldn’t change the lambda type (e.g. Func\u0026lt;someRuntimeVariable, bool\u0026gt;) as generics require a compile time type definition. All of the examples I was able to find always knew the object type on compile time. Took me some time to figure it out but the fix was fairly simple in the end. All I had to do was convert the type of “item” to the correct type in the Expression.Property call.\n1 2 3 4 // Where(item =\u0026gt; item.SomeProperty) var property = Expression .Property(Expression.Convert(item, objectType), \u0026#34;SomeProperty\u0026#34;); So the code would end up looking like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Declare the parameter we\u0026#39;re accessing var item = Expression.Parameter(typeof(object), \u0026#34;item\u0026#34;); // Where(item =\u0026gt; item) var property = Expression .Property( Expression.Convert(item, objectType), \u0026#34;SomeProperty\u0026#34; ); // Where(item =\u0026gt; item.Contains) var containsMethod = typeof(string) .GetMethod(\u0026#34;Contains\u0026#34;, new[] {typeof(string)}); // Where(item =\u0026gt; item.Contains(\u0026#34;foo\u0026#34;)) var searchExpression = Expression.Constant(\u0026#34;foo\u0026#34;, typeof(string)); // Call the \u0026#34;Contains\u0026#34; method for the \u0026#34;SomeProperty\u0026#34; var methodExpression = Expression .Call(property, method, searchExpression); // Wrap the method into a lambda var lambda = Expression .Lambda\u0026lt;Func\u0026lt;object, bool\u0026gt;\u0026gt;(methodExpression, item); // Do the NHibernate search with the lambda var result = session.Query\u0026lt;object\u0026gt;(objectType.FullName) .Where(lambda); I could now replace the constants “SomeProperty” and “foo” with a variable and make it possible to do dynamic queries based on user input.\nThis was a rather short but very interesting peek into the internals of LINQ queries. C# expression trees are a powerful feature that let you do complex things that just aren’t possible using LINQ.\n","permalink":"https://jussihaapanen.com/posts/dynamic-queries-using-nhibernate/","summary":"\u003cp\u003eI had to recently figure out a way to query database objects based on user input without knowing beforehand which classes user wants to query. Basically user would input a type and the system would find it’s child types from a database table. The children would then be fetched based on a set of rules (we do not want all items on the table, just the ones linked to the parent).\u003c/p\u003e","title":"Dynamic queries using NHibernate with the help of C# expression trees"}]