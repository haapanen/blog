<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>.NET Core plugin dependency injection | Jussi&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It&rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in Creating an application with plugin support.
It&rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I&rsquo;d prefer to be initialized and injected by the .NET Core DI.">
<meta name="author" content="Jussi Haapanen">
<link rel="canonical" href="https://jussihaapanen.com/posts/dotnet-core-plugin-dependency-injection/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5fe57f96e8bd4b053150e97725ce1ee64f04ecd17ce2a1eca44fefb55c62ceb3.css" integrity="sha256-X&#43;V/lui9SwUxUOl3Jc4e5k8E7NF84qHspE/vtVxizrM=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jussihaapanen.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jussihaapanen.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jussihaapanen.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jussihaapanen.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://jussihaapanen.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://jussihaapanen.com/posts/dotnet-core-plugin-dependency-injection/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content=".NET Core plugin dependency injection" />
<meta property="og:description" content="Introduction
You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It&rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in Creating an application with plugin support.
It&rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I&rsquo;d prefer to be initialized and injected by the .NET Core DI." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jussihaapanen.com/posts/dotnet-core-plugin-dependency-injection/" />
<meta property="og:image" content="https://jussihaapanen.com/images/avatar.jpg" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-07T12:35:16+03:00" />
<meta property="article:modified_time" content="2020-07-07T12:35:16+03:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://jussihaapanen.com/images/avatar.jpg" />
<meta name="twitter:title" content=".NET Core plugin dependency injection"/>
<meta name="twitter:description" content="Introduction
You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It&rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in Creating an application with plugin support.
It&rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I&rsquo;d prefer to be initialized and injected by the .NET Core DI."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jussihaapanen.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": ".NET Core plugin dependency injection",
      "item": "https://jussihaapanen.com/posts/dotnet-core-plugin-dependency-injection/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": ".NET Core plugin dependency injection",
  "name": ".NET Core plugin dependency injection",
  "description": "Introduction You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It\u0026rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in Creating an application with plugin support.\nIt\u0026rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I\u0026rsquo;d prefer to be initialized and injected by the .NET Core DI.\n",
  "keywords": [
    
  ],
  "articleBody": "Introduction You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It’s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in Creating an application with plugin support.\nIt’s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I’d prefer to be initialized and injected by the .NET Core DI.\nExample case Imagine we’re developing a software where we receive messages from an external system and would like to deliver those to various other systems. We could implement the event handler as an Azure Function Appyo and add various integrations to other systems.\nOverview of the imaginary system\nIn the example code I’ve implemented the event handler as a .NET Core background service. The full example code is available at GitHub\nWe’ll use the .NET Core documentation plugin application example as the starting point for the system. In the example the project structure is following:\nAppWithPlugin PluginBase HelloPlugin In our case we’ll be implementing something similar with slightly different names:\nAppWithPlugin --\u003e NetCorePluginDI PluginBase --\u003e NetCorePluginDI.PluginBase HelloPlugin --\u003e NetCorePluginDI.Integrations.* Most of the code will stay the same.\nAs the plugins will be integrations, I’ve named the IPlugin interface from the original example to IIntegration. The rest of the interface stays mostly the same:\n1 2 3 4 5 6 public interface IIntegration { string Name { get; } string Description { get; } Task ExecuteAsync(string message, CancellationToken cancellationToken); } This interface will be implemented by all of the plugins (Blob storage, HTTP and DB plugin). Below is a simplified version of the blob storage plugin.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class BlobStorageArchiveIntegration : IIntegration { private readonly ILogger\u003cBlobStorageArchiveIntegration\u003e _logger; public BlobStorageArchiveIntegration(ILogger\u003cBlobStorageArchiveIntegration\u003e logger) { _logger = logger; } public string Name { get; } = \"Blob Storage Archive\"; public string Description { get; } = \"An integration to archive messages to Blob Storage\"; public Task ExecuteAsync(string message, CancellationToken cancellationToken) { // Let's pretend we're archiving to Blob Storage _logger.LogInformation($\"Archiving message [{message}] to Blob Storage\"); return Task.CompletedTask; } } It will receive a message and “store” it to the blob storage (for demonstration purposes we’ll just log the message).\nThe problem The above example with the original plugin example will work but there’s one major issue: All of the plugins need some sort of configuration. Blob storage and DB integrations need a connection string, HTTP integration needs an URL to send the message to.\nWe could approach this by initializing the settings in the plugin by reading the settings from a file, injecting and using the IConfiguration interface or through some other method. However it would require us to define the settings initialization logic for each integration separately.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class BlobStorageArchiveIntegration : IIntegration { private readonly ILogger\u003cBlobStorageArchiveIntegration\u003e _logger; public BlobStorageArchiveIntegration(ILogger\u003cBlobStorageArchiveIntegration\u003e logger) { _logger = logger; } public string Name { get; } = \"Blob Storage Archive\"; public string Description { get; } = \"An integration to archive messages to Blob Storage\"; public Task InitializeAsync() { // Read settings from somewhere and store them locally // ... } public Task ExecuteAsync(string message, CancellationToken cancellationToken) { // Let's pretend we're archiving to Blob Storage _logger.LogInformation($\"Archiving message [{message}] to Blob Storage\"); return Task.CompletedTask; } } I’d prefer not having to specify initialization logic on each integration. Additionally this is pretty much a solved problem by the .NET Core DI, we could just use it instead.\nThe solution Let’s define a class that we’ll inject to the integration.\n1 2 3 4 public class HttpIntegrationSettings { public string Url { get; set; } } Let’s use the settings in the integration.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HttpIntegration : IIntegration { private readonly ILogger\u003cHttpIntegration\u003e _logger; private readonly HttpIntegrationSettings _settings; public HttpIntegration(ILogger\u003cHttpIntegration\u003e logger, HttpIntegrationSettings settings) { _logger = logger; _settings = settings; } public string Name { get; } = \"HTTP\"; public string Description { get; } = \"An integration to send messages to a REST endpoint\"; public Task ExecuteAsync(string message, CancellationToken cancellationToken) { // Let's pretend we're sending messages to another service _logger.LogInformation($\"Sending message [{message}] to [{_settings.Url}]\"); return Task.CompletedTask; } } Now the question is, how will we inform the DI framework about the HttpIntegrationSettings class and that it should load the settings from the IConfiguration providers?\nWe can achieve that by changing the module loading code. Let’s start by defining an interface that all injected settings classes will be implementing.\n1 2 3 public interface ISettings { } Let’s just define an empty interface. It’s just to declare the type is injectable as an interface. We could also use a naming convention such as if type name ends in Settings, we’ll inject it as settings. I prefer to be explicit.\nOnce we’ve added the ISetting interface and implemented it in HttpIntegrationSettings, we can implement the additional plugin code to instantiate and inject settings instances to the service provider.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 private static void RegisterIntegrationsFromAssembly(IServiceCollection services, IConfiguration configuration, Assembly assembly) { foreach (var type in assembly.GetTypes()) { // Register all classes that implement the IIntegration interface if (typeof(IIntegration).IsAssignableFrom(type)) { // Add as a singleton as the Worker is a singleton and we'll only have one // instance. If this would be a Controller or something else with clearly defined // scope that is not the lifetime of the application, use AddScoped. services.AddSingleton(typeof(IIntegration), type); } // Register all classes that implement the ISettings interface if (typeof(ISettings).IsAssignableFrom(type)) { var settings = Activator.CreateInstance(type); // appsettings.json or some other configuration provider should contain // a key with the same name as the type // e.g. \"HttpIntegrationSettings\": { ... } if (!configuration.GetSection(type.Name).Exists()) { // If it does not contain the key, throw an error throw new ArgumentException($\"Configuration does not contain key [{type.Name}]\"); } configuration.Bind(type.Name, settings); // Settings can be singleton as we'll only ever read it services.AddSingleton(type, settings); } } } We’ll register the integration as previously. For all interfaces implementing the ISettings interface we’ll create the instance for the type. Then we’ll ensure that the type name exists as a key in the settings (e.g. appsettings.json, environment variables or in another configuration provider). If the key exists, let’s bind the object to the instance and register the settings to the service provider.\nThis way we’ll able utilize the existing infrastructure to load settings for the plugins.\nLet’s run the application:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Loading integrations from: \\Path\\To\\NetCorePluginDI\\NetCorePluginDI.Integrations.BlobStorageArchive\\bin\\Debug\\netstandard2.0\\NetCorePluginDI.Integrations.BlobStorageArchive.dll Loading integrations from: \\Path\\TNetCorePluginDI\\NetCorePluginDI.Integrations.Http\\bin\\Debug\\netstandard2.0\\NetCorePluginDI.Integrations.Http.dll info: NetCorePluginDI.Integrations.BlobStorageArchive.BlobStorageArchiveIntegration[0] Archiving message [Worker running at: 6.7.2020 21.51.14 +03:00] to Blob Storage info: NetCorePluginDI.Integrations.Http.HttpIntegration[0] Sending message [Worker running at: 6.7.2020 21.51.14 +03:00] to [https://localhost:3000/api/message] info: Microsoft.Hosting.Lifetime[0] Application started. Press Ctrl+C to shut down. info: Microsoft.Hosting.Lifetime[0] Hosting environment: Development info: Microsoft.Hosting.Lifetime[0] Content root path: \\Path\\To\\\\NetCorePluginDI\\NetCorePluginDI info: NetCorePluginDI.Integrations.BlobStorageArchive.BlobStorageArchiveIntegration[0] Archiving message [Worker running at: 6.7.2020 21.51.15 +03:00] to Blob Storage info: NetCorePluginDI.Integrations.Http.HttpIntegration[0] Sending message [Worker running at: 6.7.2020 21.51.15 +03:00] to [https://localhost:3000/api/message] As you can see, we’ll load integrations from two DLLs, the Blob Storage and HTTP integration DLLs. The system receives a message every second and sends it to the integrations. In the log output you can see HttpIntegration logging the endpoint url that was defined in the project appsettings.json (https://localhost:3000/api/message).\nThis can be extended even further. If we have a type we’d like to inject to the plugin we can implement another interface. Let’s call it IInjectedDependency. It’s an empty interface. All types that implement this interface will be registered to the service provider.\n1 2 3 4 5 6 7 8 9 10 11 public interface IInjectedDependency { } public class Service : IInjectedDependency { public void DoWork() { // ... } } We could then register all the types implementing IInjectedDependency in the RegisterIntegrationsFromAssembly method.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 if (typeof(IInjectedDependency).IsAssignableFrom(type)) { // Get all of the interfaces the type implements except // the IInjectedDependency var implementedInterfaces = type.GetInterfaces().Where(i =\u003e i != typeof(IInjectedDependency)).ToList(); // Register as implemented interfaces if (implementedInterfaces.Any()) { foreach (var interfaceType in implementedInterfaces) { // Injected dependency lifetime must be considered // Transient is used as an example but correct lifetime // must be specified based on the use case services.AddTransient(interfaceType, type); } } else { // No implemented interface, register as self services.AddTransient(type); } } Additionally we’ll check if the type implements any interfaces. If it does, we’ll register the type as implemented interfaces. If not, we’ll register to type as self.\nThis way we can fully utilize the .NET Core DI framework within the plugins.\n",
  "wordCount" : "1585",
  "inLanguage": "en",
  "image": "https://jussihaapanen.com/images/avatar.jpg","datePublished": "2020-07-07T12:35:16+03:00",
  "dateModified": "2020-07-07T12:35:16+03:00",
  "author":{
    "@type": "Person",
    "name": "Jussi Haapanen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jussihaapanen.com/posts/dotnet-core-plugin-dependency-injection/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jussi's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jussihaapanen.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jussihaapanen.com/" accesskey="h" title="Jussi&#39;s Blog (Alt + H)">Jussi&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jussihaapanen.com/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jussihaapanen.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jussihaapanen.com/">Home</a>&nbsp;»&nbsp;<a href="https://jussihaapanen.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      .NET Core plugin dependency injection
    </h1>
    <div class="post-meta"><span title='2020-07-07 12:35:16 +0300 EEST'>July 7, 2020</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Jussi Haapanen

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#example-case" aria-label="Example case">Example case</a></li>
                <li>
                    <a href="#the-problem" aria-label="The problem">The problem</a></li>
                <li>
                    <a href="#the-solution" aria-label="The solution">The solution</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>You might run into a case where you would like to extend the application without updating the application core. Plugins could be one solution for the issue. It&rsquo;s fairly simple to implement a plugin architecture in .NET Core. Microsoft has documented the process of adding plugin support for your application in <a href="https://docs.microsoft.com/en-us/dotnet/core/tutorials/creating-app-with-plugin-support">Creating an application with plugin support</a>.</p>
<p>It&rsquo;s a good quick start to plugin architecture and gets you quite far. However, it does not explain how to add support for dependency injection from host process to the plugin process. Plugins own internal dependencies could be created on plugin initialization and injected to the executing code but I prefer to have the .NET Core dependency injection system handle these dependencies as well. Plugin configuration is a good example of an object I&rsquo;d prefer to be initialized and injected by the .NET Core DI.</p>
<h1 id="example-case">Example case<a hidden class="anchor" aria-hidden="true" href="#example-case">#</a></h1>
<p>Imagine we&rsquo;re developing a software where we receive messages from an external system and would like to deliver those to various other systems. We could implement the event handler as an Azure Function Appyo and add various integrations to other systems.</p>
<p><img loading="lazy" src="/images/dotnet-core-plugin-dependency-injection/overview.png" alt="Overview of the imaginary system"  />
</p>
<p>Overview of the imaginary system</p>
<p>In the example code I&rsquo;ve implemented the event handler as a .NET Core background service. The full example code is available at <a href="https://github.com/haapanen/NetCorePluginDI">GitHub</a></p>
<p>We&rsquo;ll use the .NET Core documentation plugin application example as the starting point for the system. In the example the project structure is following:</p>
<pre tabindex="0"><code>AppWithPlugin
PluginBase
HelloPlugin
</code></pre><p>In our case we&rsquo;ll be implementing something similar with slightly different names:</p>
<pre tabindex="0"><code>AppWithPlugin --&gt; NetCorePluginDI
PluginBase --&gt; NetCorePluginDI.PluginBase
HelloPlugin --&gt; NetCorePluginDI.Integrations.*
</code></pre><p>Most of the code will stay the same.</p>
<p>As the plugins will be integrations, I&rsquo;ve named the IPlugin interface from the original example to IIntegration. The rest of the interface stays mostly the same:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">interface</span> <span class="nc">IIntegration</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Task</span> <span class="n">ExecuteAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This interface will be implemented by all of the plugins (Blob storage, HTTP and DB plugin). Below is a simplified version of the blob storage plugin.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">BlobStorageArchiveIntegration</span> <span class="p">:</span> <span class="n">IIntegration</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">ILogger</span><span class="p">&lt;</span><span class="n">BlobStorageArchiveIntegration</span><span class="p">&gt;</span> <span class="n">_logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">BlobStorageArchiveIntegration</span><span class="p">(</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">BlobStorageArchiveIntegration</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">&#34;Blob Storage Archive&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">&#34;An integration to archive messages to Blob Storage&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Task</span> <span class="n">ExecuteAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Let&#39;s pretend we&#39;re archiving to Blob Storage</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Archiving message [{message}] to Blob Storage&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>It will receive a message and &ldquo;store&rdquo; it to the blob storage (for demonstration purposes we&rsquo;ll just log the message).</p>
<h1 id="the-problem">The problem<a hidden class="anchor" aria-hidden="true" href="#the-problem">#</a></h1>
<p>The above example with the original plugin example will work but there&rsquo;s one major issue: All of the plugins need some sort of configuration. Blob storage and DB integrations need a connection string, HTTP integration needs an URL to send the message to.</p>
<p>We could approach this by initializing the settings in the plugin by reading the settings from a file, injecting and using the IConfiguration interface or through some other method. However it would require us to define the settings initialization logic for each integration separately.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">BlobStorageArchiveIntegration</span> <span class="p">:</span> <span class="n">IIntegration</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">ILogger</span><span class="p">&lt;</span><span class="n">BlobStorageArchiveIntegration</span><span class="p">&gt;</span> <span class="n">_logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">BlobStorageArchiveIntegration</span><span class="p">(</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">BlobStorageArchiveIntegration</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">&#34;Blob Storage Archive&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">&#34;An integration to archive messages to Blob Storage&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="n">Task</span> <span class="n">InitializeAsync</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// Read settings from somewhere and store them locally</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Task</span> <span class="n">ExecuteAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Let&#39;s pretend we&#39;re archiving to Blob Storage</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Archiving message [{message}] to Blob Storage&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>I&rsquo;d prefer not having to specify initialization logic on each integration. Additionally this is pretty much a solved problem by the .NET Core DI, we could just use it instead.</p>
<h1 id="the-solution">The solution<a hidden class="anchor" aria-hidden="true" href="#the-solution">#</a></h1>
<p>Let&rsquo;s define a class that we&rsquo;ll inject to the integration.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">HttpIntegrationSettings</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s use the settings in the integration.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">HttpIntegration</span> <span class="p">:</span> <span class="n">IIntegration</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">ILogger</span><span class="p">&lt;</span><span class="n">HttpIntegration</span><span class="p">&gt;</span> <span class="n">_logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">readonly</span> <span class="n">HttpIntegrationSettings</span> <span class="n">_settings</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">HttpIntegration</span><span class="p">(</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">HttpIntegration</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">,</span> <span class="n">HttpIntegrationSettings</span> <span class="n">settings</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_settings</span> <span class="p">=</span> <span class="n">settings</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">&#34;HTTP&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">string</span> <span class="n">Description</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="s">&#34;An integration to send messages to a REST endpoint&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Task</span> <span class="n">ExecuteAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Let&#39;s pretend we&#39;re sending messages to another service</span>
</span></span><span class="line"><span class="cl">        <span class="n">_logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Sending message [{message}] to [{_settings.Url}]&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now the question is, how will we inform the DI framework about the HttpIntegrationSettings class and that it should load the settings from the IConfiguration providers?</p>
<p>We can achieve that by changing the module loading code. Let&rsquo;s start by defining an interface that all injected settings classes will be implementing.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">interface</span> <span class="nc">ISettings</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s just define an empty interface. It&rsquo;s just to declare the type is injectable as an interface. We could also use a naming convention such as if type name ends in Settings, we&rsquo;ll inject it as settings. I prefer to be explicit.</p>
<p>Once we&rsquo;ve added the ISetting interface and implemented it in HttpIntegrationSettings, we can implement the additional plugin code to instantiate and inject settings instances to the service provider.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="k">void</span> <span class="n">RegisterIntegrationsFromAssembly</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">,</span> <span class="n">IConfiguration</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">Assembly</span> <span class="n">assembly</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">assembly</span><span class="p">.</span><span class="n">GetTypes</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Register all classes that implement the IIntegration interface</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IIntegration</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Add as a singleton as the Worker is a singleton and we&#39;ll only have one</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// instance. If this would be a Controller or something else with clearly defined</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// scope that is not the lifetime of the application, use AddScoped.</span>
</span></span><span class="line"><span class="cl">            <span class="n">services</span><span class="p">.</span><span class="n">AddSingleton</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IIntegration</span><span class="p">),</span> <span class="n">type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Register all classes that implement the ISettings interface</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ISettings</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">settings</span> <span class="p">=</span> <span class="n">Activator</span><span class="p">.</span><span class="n">CreateInstance</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// appsettings.json or some other configuration provider should contain</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// a key with the same name as the type</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// e.g. &#34;HttpIntegrationSettings&#34;: { ... }</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(!</span><span class="n">configuration</span><span class="p">.</span><span class="n">GetSection</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">Name</span><span class="p">).</span><span class="n">Exists</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// If it does not contain the key, throw an error</span>
</span></span><span class="line"><span class="cl">                <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">$&#34;Configuration does not contain key [{type.Name}]&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">configuration</span><span class="p">.</span><span class="n">Bind</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">settings</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Settings can be singleton as we&#39;ll only ever read it</span>
</span></span><span class="line"><span class="cl">            <span class="n">services</span><span class="p">.</span><span class="n">AddSingleton</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">settings</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We&rsquo;ll register the integration as previously. For all interfaces implementing the ISettings interface we&rsquo;ll create the instance for the type. Then we&rsquo;ll ensure that the type name exists as a key in the settings (e.g. appsettings.json, environment variables or in another configuration provider). If the key exists, let&rsquo;s bind the object to the instance and register the settings to the service provider.</p>
<p>This way we&rsquo;ll able utilize the existing infrastructure to load settings for the plugins.</p>
<p>Let&rsquo;s run the application:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="nx">Loading</span> <span class="nx">integrations</span> <span class="nx">from</span><span class="o">:</span> <span class="err">\</span><span class="nx">Path</span><span class="err">\</span><span class="nx">To</span><span class="err">\</span><span class="nx">NetCorePluginDI</span><span class="err">\</span><span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">BlobStorageArchive</span><span class="err">\</span><span class="nx">bin</span><span class="err">\</span><span class="nx">Debug</span><span class="err">\</span><span class="nx">netstandard2</span><span class="mf">.0</span><span class="err">\</span><span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">BlobStorageArchive</span><span class="p">.</span><span class="nx">dll</span>
</span></span><span class="line"><span class="cl"><span class="nx">Loading</span> <span class="nx">integrations</span> <span class="nx">from</span><span class="o">:</span> <span class="err">\</span><span class="nx">Path</span><span class="err">\</span><span class="nx">TNetCorePluginDI</span><span class="err">\</span><span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">Http</span><span class="err">\</span><span class="nx">bin</span><span class="err">\</span><span class="nx">Debug</span><span class="err">\</span><span class="nx">netstandard2</span><span class="mf">.0</span><span class="err">\</span><span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">Http</span><span class="p">.</span><span class="nx">dll</span>
</span></span><span class="line"><span class="cl"><span class="nx">info</span><span class="o">:</span> <span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">BlobStorageArchive</span><span class="p">.</span><span class="nx">BlobStorageArchiveIntegration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Archiving</span> <span class="nx">message</span> <span class="p">[</span><span class="nx">Worker</span> <span class="nx">running</span> <span class="nx">at</span><span class="o">:</span> <span class="mf">6.7.2020</span> <span class="mf">21.51.14</span> <span class="o">+</span><span class="mi">03</span><span class="o">:</span><span class="mi">00</span><span class="p">]</span> <span class="nx">to</span> <span class="nx">Blob</span> <span class="nx">Storage</span>
</span></span><span class="line"><span class="cl"><span class="nx">info</span><span class="o">:</span> <span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">Http</span><span class="p">.</span><span class="nx">HttpIntegration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Sending</span> <span class="nx">message</span> <span class="p">[</span><span class="nx">Worker</span> <span class="nx">running</span> <span class="nx">at</span><span class="o">:</span> <span class="mf">6.7.2020</span> <span class="mf">21.51.14</span> <span class="o">+</span><span class="mi">03</span><span class="o">:</span><span class="mi">00</span><span class="p">]</span> <span class="nx">to</span> <span class="p">[</span><span class="nx">https</span><span class="o">:</span><span class="c1">//localhost:3000/api/message]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">info</span><span class="o">:</span> <span class="nx">Microsoft</span><span class="p">.</span><span class="nx">Hosting</span><span class="p">.</span><span class="nx">Lifetime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Application</span> <span class="nx">started</span><span class="p">.</span> <span class="nx">Press</span> <span class="nx">Ctrl</span><span class="o">+</span><span class="nx">C</span> <span class="nx">to</span> <span class="nx">shut</span> <span class="nx">down</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">info</span><span class="o">:</span> <span class="nx">Microsoft</span><span class="p">.</span><span class="nx">Hosting</span><span class="p">.</span><span class="nx">Lifetime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Hosting</span> <span class="nx">environment</span><span class="o">:</span> <span class="nx">Development</span>
</span></span><span class="line"><span class="cl"><span class="nx">info</span><span class="o">:</span> <span class="nx">Microsoft</span><span class="p">.</span><span class="nx">Hosting</span><span class="p">.</span><span class="nx">Lifetime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Content</span> <span class="nx">root</span> <span class="nx">path</span><span class="o">:</span> <span class="err">\</span><span class="nx">Path</span><span class="err">\</span><span class="nx">To</span><span class="err">\\</span><span class="nx">NetCorePluginDI</span><span class="err">\</span><span class="nx">NetCorePluginDI</span>
</span></span><span class="line"><span class="cl"><span class="nx">info</span><span class="o">:</span> <span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">BlobStorageArchive</span><span class="p">.</span><span class="nx">BlobStorageArchiveIntegration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Archiving</span> <span class="nx">message</span> <span class="p">[</span><span class="nx">Worker</span> <span class="nx">running</span> <span class="nx">at</span><span class="o">:</span> <span class="mf">6.7.2020</span> <span class="mf">21.51.15</span> <span class="o">+</span><span class="mi">03</span><span class="o">:</span><span class="mi">00</span><span class="p">]</span> <span class="nx">to</span> <span class="nx">Blob</span> <span class="nx">Storage</span>
</span></span><span class="line"><span class="cl"><span class="nx">info</span><span class="o">:</span> <span class="nx">NetCorePluginDI</span><span class="p">.</span><span class="nx">Integrations</span><span class="p">.</span><span class="nx">Http</span><span class="p">.</span><span class="nx">HttpIntegration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">Sending</span> <span class="nx">message</span> <span class="p">[</span><span class="nx">Worker</span> <span class="nx">running</span> <span class="nx">at</span><span class="o">:</span> <span class="mf">6.7.2020</span> <span class="mf">21.51.15</span> <span class="o">+</span><span class="mi">03</span><span class="o">:</span><span class="mi">00</span><span class="p">]</span> <span class="nx">to</span> <span class="p">[</span><span class="nx">https</span><span class="o">:</span><span class="c1">//localhost:3000/api/message]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see, we&rsquo;ll load integrations from two DLLs, the Blob Storage and HTTP integration DLLs. The system receives a message every second and sends it to the integrations. In the log output you can see HttpIntegration logging the endpoint url that was defined in the project appsettings.json (https://localhost:3000/api/message).</p>
<p>This can be extended even further. If we have a type we&rsquo;d like to inject to the plugin we can implement another interface. Let&rsquo;s call it IInjectedDependency. It&rsquo;s an empty interface. All types that implement this interface will be registered to the service provider.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">interface</span> <span class="nc">IInjectedDependency</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">Service</span> <span class="p">:</span> <span class="n">IInjectedDependency</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="k">void</span> <span class="n">DoWork</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// ...</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We could then register all the types implementing IInjectedDependency in the
RegisterIntegrationsFromAssembly method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IInjectedDependency</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Get all of the interfaces the type implements except</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the IInjectedDependency</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">implementedInterfaces</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetInterfaces</span><span class="p">().</span><span class="n">Where</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">i</span> <span class="p">!=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IInjectedDependency</span><span class="p">)).</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Register as implemented interfaces</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">implementedInterfaces</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">interfaceType</span> <span class="k">in</span> <span class="n">implementedInterfaces</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Injected dependency lifetime must be considered</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Transient is used as an example but correct lifetime</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// must be specified based on the use case</span>
</span></span><span class="line"><span class="cl">            <span class="n">services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">(</span><span class="n">interfaceType</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// No implemented interface, register as self</span>
</span></span><span class="line"><span class="cl">        <span class="n">services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Additionally we&rsquo;ll check if the type implements any interfaces. If it does, we&rsquo;ll register
the type as implemented interfaces. If not, we&rsquo;ll register to type as self.</p>
<p>This way we can fully utilize the .NET Core DI framework within the plugins.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://jussihaapanen.com/posts/minimal-permissions-for-azure-workbook/">
    <span class="title">« Prev</span>
    <br>
    <span>Minimal permissions for Azure Workbook, Log Analytics Workspace &amp; Application Insights</span>
  </a>
  <a class="next" href="https://jussihaapanen.com/posts/piping-data-in-dotnet-core/">
    <span class="title">Next »</span>
    <br>
    <span>Piping data to an application in .NET Core</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© Jussi Haapanen</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
